import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.159.0/build/three.module.js';

const globeContainer = document.getElementById('globe-container');
let scene, camera, renderer, globe, clouds;
let mouseX = 0, mouseY = 0;
let targetRotationX = 0, targetRotationY = 0;

function initGlobe() {
  if (!globeContainer) {
    console.error('Globe container not found');
    return;
  }
  
  scene = new THREE.Scene();
  camera = new THREE.PerspectiveCamera(45, globeContainer.clientWidth / globeContainer.clientHeight, 0.1, 1000);
  camera.position.z = 2.5;
  renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
  renderer.setSize(globeContainer.clientWidth, globeContainer.clientHeight);
  renderer.setPixelRatio(window.devicePixelRatio);
  globeContainer.appendChild(renderer.domElement);
  
  const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
  scene.add(ambientLight);
  const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
  directionalLight.position.set(5, 3, 5);
  scene.add(directionalLight);
  
  const geometry = new THREE.SphereGeometry(1, 64, 64);
  const textureLoader = new THREE.TextureLoader();
  textureLoader.crossOrigin = 'anonymous';
  
  const earthTexture = textureLoader.load(
    'https://cdn.jsdelivr.net/npm/three-globe@2.31.0/example/img/earth-blue-marble.jpg',
    () => console.log('Earth texture loaded'),
    undefined,
    (err) => console.error('Earth texture error:', err)
  );
  
  const material = new THREE.MeshPhongMaterial({ 
    map: earthTexture, 
    bumpScale: 0.05, 
    specular: new THREE.Color(0x333333), 
    shininess: 5 
  });
  globe = new THREE.Mesh(geometry, material);
  scene.add(globe);
  
  const cloudGeometry = new THREE.SphereGeometry(1.01, 64, 64);
  const cloudTexture = textureLoader.load(
    'https://cdn.jsdelivr.net/npm/three-globe@2.31.0/example/img/earth-clouds.png',
    () => console.log('Cloud texture loaded'),
    undefined,
    (err) => console.error('Cloud texture error:', err)
  );
  const cloudMaterial = new THREE.MeshPhongMaterial({ 
    map: cloudTexture, 
    transparent: true, 
    opacity: 0.4, 
    depthWrite: false 
  });
  clouds = new THREE.Mesh(cloudGeometry, cloudMaterial);
  scene.add(clouds);
  
  addCountryMarkers();
  window.addEventListener('resize', onWindowResize);
  globeContainer.addEventListener('mousemove', onMouseMove);
  animate();
  console.log('Globe initialized successfully');
}

function addCountryMarkers() {
  const countries = [
    { lat: 39.9042, lon: 116.4074, name: 'China' },
    { lat: 37.5665, lon: 126.9780, name: 'South Korea' },
    { lat: 35.6762, lon: 139.6503, name: 'Japan' },
    { lat: 40.7128, lon: -74.0060, name: 'USA' },
    { lat: 51.5074, lon: -0.1278, name: 'UK' },
    { lat: 52.5200, lon: 13.4050, name: 'Germany' },
    { lat: 48.8566, lon: 2.3522, name: 'France' }
  ];
  const markerGeometry = new THREE.SphereGeometry(0.015, 16, 16);
  const markerMaterial = new THREE.MeshBasicMaterial({ color: 0xff6b6b, transparent: true, opacity: 0.9 });
  countries.forEach(country => {
    const marker = new THREE.Mesh(markerGeometry, markerMaterial);
    const phi = (90 - country.lat) * (Math.PI / 180);
    const theta = (country.lon + 180) * (Math.PI / 180);
    marker.position.setFromSphericalCoords(1.02, phi, theta);
    globe.add(marker);
    marker.userData = { baseScale: 1 + Math.random() * 0.3, phase: Math.random() * Math.PI * 2 };
  });
  console.log('Loaded', countries.length, 'country markers');
}

function onMouseMove(event) {
  const rect = globeContainer.getBoundingClientRect();
  mouseX = ((event.clientX - rect.left) / rect.width) * 2 - 1;
  mouseY = -((event.clientY - rect.top) / rect.height) * 2 + 1;
}

function onWindowResize() {
  camera.aspect = globeContainer.clientWidth / globeContainer.clientHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(globeContainer.clientWidth, globeContainer.clientHeight);
}

function animate() {
  requestAnimationFrame(animate);
  targetRotationY = mouseX * 0.5;
  targetRotationX = mouseY * 0.3;
  globe.rotation.y += (targetRotationY - globe.rotation.y) * 0.05;
  globe.rotation.x += (targetRotationX - globe.rotation.x) * 0.05;
  globe.rotation.y += 0.001;
  if (clouds) {
    clouds.rotation.y = globe.rotation.y * 1.2;
    clouds.rotation.x = globe.rotation.x;
  }
  globe.children.forEach(child => {
    if (child.userData.baseScale) {
      const scale = child.userData.baseScale + Math.sin(Date.now() * 0.003 + child.userData.phase) * 0.2;
      child.scale.setScalar(scale);
    }
  });
  renderer.render(scene, camera);
}

async function loadNews() {
  console.log('Starting to load news...');
  try {
    const response = await fetch('./news.json');
    console.log('News fetch response:', response.status, response.statusText);
    
    if (!response.ok) {
      throw new Error(`Failed to fetch news: ${response.status} ${response.statusText}`);
    }
    
    const newsData = await response.json();
    console.log('News data received:', newsData);
    
    const newsGrid = document.getElementById('news-grid');
    if (!newsGrid) {
      console.error('news-grid element not found');
      return;
    }
    
    newsGrid.innerHTML = '';
    
    if (Array.isArray(newsData) && newsData.length > 0) {
      newsData.forEach(news => {
        const newsCard = document.createElement('div');
        newsCard.className = 'news-card';
        newsCard.innerHTML = `
          <img src="${news.image}" alt="${news.title}" onerror="this.style.display='none'" />
          <div class="news-content">
            <div class="news-date">${news.date}</div>
            <h3>${news.title}</h3>
            <p>${news.excerpt}</p>
          </div>
        `;
        newsGrid.appendChild(newsCard);
      });
      console.log('News loaded successfully:', newsData.length, 'items');
    } else {
      console.error('News data is not an array or is empty:', newsData);
    }
  } catch (error) {
    console.error('Error loading news:', error);
  }
}

const mobileMenuBtn = document.getElementById('mobile-menu-btn');
const navLinks = document.getElementById('nav-links');
if (mobileMenuBtn && navLinks) {
  mobileMenuBtn.addEventListener('click', () => {
    navLinks.classList.toggle('active');
    mobileMenuBtn.classList.toggle('active');
  });
}

document.querySelectorAll('.nav-links a').forEach(link => {
  link.addEventListener('click', () => {
    if (navLinks) navLinks.classList.remove('active');
    if (mobileMenuBtn) mobileMenuBtn.classList.remove('active');
  });
});

document.querySelectorAll('a[href^="#"]').forEach(anchor => {
  anchor.addEventListener('click', function (e) {
    e.preventDefault();
    const target = document.querySelector(this.getAttribute('href'));
    if (target) target.scrollIntoView({ behavior: 'smooth', block: 'start' });
  });
});

const observer = new IntersectionObserver((entries) => {
  entries.forEach(entry => {
    if (entry.isIntersecting) {
      entry.target.classList.add('animate');
      observer.unobserve(entry.target);
    }
  });
}, { threshold: 0.1, rootMargin: '0px 0px -50px 0px' });

document.querySelectorAll('.product-card, .news-card, .stat-card').forEach(el => observer.observe(el));

document.addEventListener('DOMContentLoaded', () => {
  console.log('DOM loaded, initializing...');
  if (globeContainer) {
    initGlobe();
  } else {
    console.error('Globe container not found in DOM');
  }
  loadNews();
});

document.querySelectorAll('.language-btn').forEach(btn => {
  btn.addEventListener('click', () => {
    const lang = btn.dataset.lang;
    document.querySelectorAll('.language-btn').forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
    document.documentElement.lang = lang === 'zh' ? 'zh-CN' : 'en';
  });
});
